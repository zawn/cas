---
layout: 违约
title: CAS - 属性发布策略
category: 属性
---

# 属性发布策略

属性发布策略决定如何在 CAS 最终响应中选择属性并提供给给定的应用程序。 此外，每个策略都能够应用可选筛选器来清除其基于其值的属性。

所有属性发布策略共享以下设置：

| 名字         | 价值                                                                                           |
| ---------- | -------------------------------------------------------------------------------------------- |
| `授权发布信用密码` | Boolean 定义服务是否有权 [发布凭据作为属性](ClearPass.html)。                                                 |
| `授权发布价格授权` | Boolean 定义该服务是否有权 [发布代理授予票证 ID 作为属性](../installation/Configuring-Proxy-Authentication.html)。 |
| `不包括不良属性`  | Boolean 定义此策略是否应排除用于发布的默认全球属性捆绑。                                                             |
| `授权发布授权属性` | Boolean 定义此策略是否应排除发布的身份验证/协议属性。 身份验证属性被视为与特定主体无关的属性，并定义有关身份验证事件本身的额外补充元数据，例如开始日期。            |
| `本金`       | 您自己选择的属性名称，将塞入最终的属性捆绑中，带有 CAS 认证的主要标识符。 默认情况下，本金 ID *而不是作为属性* 发布。                            |

<div class="alert alert-warning"><strong>使用警告！</strong><p>在打开上述设置之前， <strong></strong> 仔细思考。 盲目授权申请接收代理授权票证或用户凭据
可能会产生安全泄漏和攻击的机会。 确保您确实需要启用这些功能，并且您了解原因。 避免在可能的地方和时间，特别是当涉及到共享用户凭据。</p></div>

CAS 区分传达身份验证事件元数据的属性与包含身份验证委托人个人可识别数据的属性 。

## 行政终点

CAS 提供以下端点：

| 端点     | 描述                                                                  |
| ------ | ------------------------------------------------------------------- |
| `释放属性` | 调用 CAS [](../integration/Attribute-Release.html) 引擎的属性释放来释放应用程序的属性。 |

支持参数如下：

| 查询参数  | 描述          |
| ----- | ----------- |
| `用户名` | 用于身份验证的用户名。 |
| `密码`  | 用于身份验证的密码。  |
| `服务`  | 应发布哪些属性的服务。 |

以上参数可以添加为查询字符串参数，也可以添加为与POST一起提交的 JSON 对象：

```json
{ 
  "用户名"："用户名"，
  "密码"："密码"，
  "服务"："SERVICE_URL"
}
```

## 身份验证属性

在身份验证过程中，CAS 捕获并收集了一些属性，以描述有关身份验证事件本身性质的元数据和其他属性。 这些通常包括由基础协议 记录和分类的属性，或特定于 CAS 的属性，这些属性可以描述所使用的凭据类型、成功执行的 身份验证处理程序、身份验证的日期/时间等。

向服务提供商和应用程序发布身份验证属性可以在一定程度上 控制。 要了解更多，并查看 CAS 属性的相关列表，请 [](../configuration/Configuration-Properties.html#authentication-attributes)查看本指南。

## 主要属性

主要属性通常传达有关身份验证用户的个人可识别数据， ，如地址、姓氏等。 发布策略可在 CAS 中提供，并记录在以下 ，以明确控制可能授权发布给定应用程序的属性的集合。

<div class="alert alert-info"><strong>记得</strong><p>根据所使用的协议和在 CAS 注册的服务类型/类别（即依赖方），可能会提供
额外的发布策略，以便对属性释放进行更微调的控制，更好地满足手头特定
认证协议的需求。 请记住，通过访问和研究每个协议的适当文档来验证 CAS 的属性释放功能。</p></div>

### 违约

CAS 提供默认向所有服务发布捆绑主要属性的能力。 此捆绑包不是按服务定义的，并且始终与服务特定发布策略产生的属性相结合，例如，您可以设计规则，以便始终发布 `给定名` 和 `cn` 每个应用程序，此外，仅允许其他特定主要属性仅针对其属性发布策略的某些应用程序。

要查看 CAS 属性的相关列表，请 [查看本指南](../configuration/Configuration-Properties.html#default-bundle)。

### 全部返回

将所有已解决的主要属性返回到服务中。

```json
•
  "@class"："组织.apereo.cas.服务.注册服务"，
  "服务id"："样本"，
  "名称"："样本"，
  "id"：100，
  "属性释放政策"：{
    "@class"："org.apereo.cas.服务。返回所有归因释放政策"
  =
}
```

### 拒绝所有

切勿将主要属性返回到应用程序。 请注意，此策略 也会跳过并拒绝发布默认属性（如果有的话）。

```json
•
  "@class"："组织.apereo.cas.服务.注册服务"，
  "服务"："样本"，
  "名称"："样本"，
  "id"：100，
  "描述"："样本"，
  "属性重新发布政策"：{
    "@class"："org.apereo.cas.services

  .服务。
```

### 允许返回

仅返回服务定义明确允许的主要属性。

```json
•
  "@class"："org.apereo.cas.服务.注册服务"，
  "服务ID"："样本"，
  "名称"："样本"，
  "id"：100，
  "属性释放政策"： [
    "@class" ： "org. apereo. cas. 服务.返回允许的属性释放政策"，
    "允许的属性" ： [ java. util. Arraylist"， [cn"， "邮件"， "sn" ]
  [
]
```

### 返回加密

使用分配的注册服务公钥加密和编码 base-64 中所有允许的属性。

```json
•
  "@class"："org.apereo.cas.服务.注册服务"，
  "服务ID"："样本"，
  "名称"： "样本"，
  "id"： 100，
  "属性释放政策"： [
    "@class"： "org. apereo. cas. 服务. 返回加密属性释放政策"，
    "允许属性"： [ "java. ut. [cn"，"邮件"，"sn"]][
  ]，
  "公共钥匙"：{
    "@class"："org.apereo.cas.服务。注册服务公共钥匙"，
    "位置"："类路径：公共.key"，
    "算法"："RSA"
  }
}
```

密钥可以通过以下命令生成：

```bash
打开斯尔根萨 - 出私人.key 1024
打开斯尔 rsa - 酒吧 - 在私人.key - 出公共.key - 通知 Pem - 超越 Der
打开 pkcs8 - topk8 - 通知每 - 通知佩尔 - 诺克里普特 - 在私人.key - 出私人. p8
```

### 休息

仅返回通过联系 REST 端点明确允许的主要属性。 端点必须设计为接受/处理 `申请/json`。 预期响应状态代码 `200` 响应主体包括与其值相关的属性 `地图` 。

```json
•
  "@class"："org.apereo.cas.服务.注册服务"，
  "服务ID"："示例"，
  "名称"："样本"，
  "id"：100，
  "属性释放政策"：{
    "@class"："org.apereo.cas.服务。返回属性释放政策"，
    "终点"："https://somewhere.example.org"
  =
}
```

以下参数传递到终点：

| 参数   | 描述               |
| ---- | ---------------- |
| `主要` | 表示经过验证的主体的对象。    |
| `服务` | 表示注册表中相应服务定义的对象。 |

提交请求的主体可能还包括当前已解决属性的 `地图` 。

### 返回映射

与上述类似，本政策将返回 服务允许的主要属性集合，但也允许在更精细的服务级别上映射和"重命名"这些主要属性。

例如，下列配置将识别已解决的 属性 `eduPerson 关联` 和 `组成员` ，然后 发布 `从属关系` 和 `组` 到已配置的 Web 应用程序。

```json
•
  "@class"："org.apereo.cas.服务.注册服务"，
  "服务ID"："样本"，
  "名称"："样本"，
  "id"：300，
  "描述"："样本"，
  "属性释放政策"：{
    "@class"："org.apereo.cas.服务。返回地图属性释放政策"，
    "允许属性"：{
      "@class" ："java.util.TreeMap"，
      "爱德华人隶属关系"："从属关系"，
      "团体成员"："群体"
    }
  }
}
```

### 返回多映射

同一策略可能允许属性定义重命名并重新映射为多个属性名称， 具有映射到不同名称的重复属性值。

例如，下列配置将识别已解决的属性 `教育人隶属关系` ，然后发布 `从属关系` 和 `人从属关系` 其值源于原始 `教育人隶属关系` 属性，而 `组成员` 则发布为 `组`。 换句话说， `教育人隶属关系` 属性以两个不同的名称发布两次，每个名称共享相同的值。

```json
•
  "@class"："组织.apereo.cas.服务.注册服务"，
  "服务ID"："样本"，
  "名称"："样本"，
  "id"：300，
  "属性释放政策"：{
    "@class"："org.apereo.cas.服务。
    "允许归因"：{
      "@class"："java.util.TreeMap"，
      "爱德华个人从属关系"：["java.3" [组织列表]，"从属关系"，"人格关系"]]，
      "群体成员"："组"
    }
  }
}
```

### 内联沟属性

映射的主要属性可能从内联凹槽脚本生成其值。 例如，如果您目前 已解决了具有 `吹笛器`值的 `uid` 属性，则可以考虑以下几点：

```json
•
  "@class"："org.apereo.cas.服务.注册服务"，
  "服务ID"："样本"，
  "名称"："样本"，
  "id"：300，
  "属性释放政策"：{
    "@class"："org.apereo.cas.服务。返回地图属性释放政策"，
    "允许属性"：{
      "@class
      ："java.ul.treemap"，"uid"："凹凸不正的{返回属性['uid'。get（0）][伟大'}"
    }
  }
}
```

在上面的片段中， `uid` 属性名称的值映射到内联凹槽脚本的结果。 内联脚本始终从语法 `凹凸不平的 {...}` 开始，并通过已解决的 属性的当前集合，作为 `属性` 绑定变量。 脚本的结果可以是单个/收集值。

上述配置将为其价值与 `uid` 的原始值相 加上"很棒"字样的应用程序产生 `uid` 属性，因此最终结果将是"派珀是伟大的"。

### 基于文件的格罗夫属性

与内联凹槽属性定义相同，但凹槽脚本除外化为 `。groovy` 文件：

```json
•
  "@class"："org.apereo.cas.服务.注册服务"，
  "服务ID"："样本"，
  "名称"："样本"，
  "id"：300，
  "属性释放政策"：{
    "@class"："org.apereo.cas.服务。返回地图属性释放政策"，
    "允许属性"：{
      "@class"："java.util.Treemap"，
      "uid"："文件：/等/cas/sample.groovy"
    =
  =
}
```

`示例.groovy` 脚本本身可能有以下大纲：

```groovy
导入java.利用。*

def运行（最终对象。。。args）{
    def属性=args[0]
    def记录器=args[1]
    记录器。debug（"当前属性是{}，属性）
    返回[]
}
```

此组件的配置有资格使用 [弹簧表达语言](../configuration/Configuration-Spring-Expressions.html) 语法。

### 格罗夫脚本

让外部 Groovy 脚本决定如何发布主要属性。 此 组件的配置有资格使用 [弹簧表达语言](../configuration/Configuration-Spring-Expressions.html) 语法。

```json
•
  "@class"："org.apereo.cas.服务.注册服务"，
  "服务ID"："示例"，
  "名称"："示例"，
  "id"：300，
  "属性释放政策"：{
    "@class"："org.apereo.cas.服务"。Groovy脚本属性发布政策"，
    "凹槽脚本"："类路径：/脚本。groovy"
  =

```

脚本本身可在 Groovy 中设计为：

```groovy
导入java.util.*

d地图<String, List<Object>> 运行（最终对象。。。args）{
    定义当前属性=args[0]
    d记录器=args[1]
    def本金=args[2]
    def服务=args[3]

    记录器。debug（"收到的当前属性是{}" 当前归因）
    返回[用户名：["东西"]，喜欢：["奶酪"，"食物"]，id：[1234，2，3，4，5]，另一个："属性"]
]
```

以下参数传递到脚本：

| 参数     | 描述                                |
| ------ | --------------------------------- |
| `当前属性` | `地图` 当前已解决并可供发布的属性。               |
| `记录`   | 负责发布日志消息的对象，如 `logger.info（。。。）`。 |
| `主要`   | 表示经过验证的主体的对象。                     |
| `服务`   | 表示注册表中相应服务定义的对象。                  |

### 脚本引擎

<div class="alert alert-warning"><strong>用法</strong>
<p><strong>此功能被弃用，并计划在将来删除。</strong></p>
</div>

使用替代脚本引擎实现和其他编程语言来配置属性发布策略。 此方法 利用通过其他库和驱动程序内置于 Java 平台中的脚本功能。 虽然 Groovy 应由 CAS 本地支持，但叠加中需要以下模块，以包括支持其他语言 如 Python 等。

```xml
<dependency>
    <groupId>组织.apereo.cas</groupId>
    <artifactId>套机服务器支持脚本-脚本-发动机</artifactId>
    <version>${cas.version}</version>
</dependency>
```

然后，服务定义可以设计为：

```json
•
  "@class"："组织.apereo.cas.服务.注册服务"，
  "服务ID"："样本"，
  "名称"："样本"，
  "id"：300，
  "属性释放政策"：\
    "@class"："org.apereo.cas.服务.服务.脚本注册服务发布政策"，
    "脚本文件"："类路径"：。
  ||葡萄干]=
}
```

此组件的配置有资格 [春季表达语言](../configuration/Configuration-Spring-Expressions.html) 语法中使用。 脚本 需要设计一个 `运行` 函数，该函数接收参数列表。 过程中当前属性的集合 以及记录器对象传递到此函数。 结果必须生成一张地图，其 `个关键`是属性名称 ，其 `值`是属性值列表。

例如，脚本本身可在 Groovy 中设计为：

```groovy
导入java.util.*

d地图<String, List<Object>> 运行（最终对象。。。args）{
    定义当前属性=args[0]
    d记录器=args[1]

    记录器。debug（"收到的当前属性是{}" 当前属性）
    返回[用户名：["某物"]，如：["奶酪"，"食物"]，id：[1234，2，3，4，5]，另一个："属性"]
]
```

下面是用 Python 编写的相同脚本：

```python
def运行（*参数）：
  属性=参数[0]
  记录器=参数[1]
  #计算属性并返回新的属性词典。。。
  返回。。。
```

还允许您将内衬凹槽脚本塞入 `脚本文件` 属性中。 脚本 有权访问已解决的 `属性` 以及 `记录器` 对象的集合。

```json
•
  "@class"："org.apereo.cas.服务.注册服务"，
  "服务ID"："示例"，
  "名称"："示例"，
  "id"：300，
  "属性释放政策"：{
    "@class"："org.apereo.cas.服务.脚本注册服务归因发布政策"，
    "脚本文件"："凹凸不仁 { return attributes }"
  }

```

### 链条策略

属性释放策略可以链接在一起处理多个规则。 策略调用顺序与为服务本身定义的定义顺序相同。

```json
•
  "@class"："组织.apereo.cas.服务.注册服务"，
  "服务"："样本"，
  "名称"："样本"，
  "id"：300，
  "属性释放政策"：{
    "@class"："org.apereo.cas.服务。
    "合并政策"："替换"，
    "政策"："java.ul.Arraylist"，
      [
          {"@class"："......"，
          {"@class"："。。。"
      [
    ]
  }
}
```

支持以下合并政策：

| 政策    | 描述                     |
| ----- | ---------------------- |
| `取代`  | 属性被合并，因此源中的属性始终替换主要属性。 |
| `加`   | 属性被合并，因此产生本金不存在的来源属性。  |
| `多价值` | 同名属性合并为多值属性。           |

#### 订购策略

请注意，链中的每个策略都可以</code> 分配一个数字 `订单，在执行前确定其在链中的位置。 如果您的属性释放策略应先动态计算值，然后再将其传递到链中的下一个策略
，则此
订单可能很重要。 </p>

<p spaces-before="0">例如，下面的政策链允许 CAS 首先使用"生成" <code>生成"发布政策` 策略 在该属性下一个传递到链中的下一个策略（即 `发布"发布政策`，以决定 是否应发布属性。 注意策略 `命令的配置` 决定执行顺序。

```json
•
  "@class"："组织.apereo.cas.服务.注册服务"，
  "服务id"："样本"，
  "名称"："样本"，
  "id"：300，
  "属性释放政策"：{
    "@class"："org.apereo.cas.服务。
    "政策"： [java. util. Arraylist"，
      [
          ]
            "@class"： "org. apereo. cas. 发布婴儿归因释放政策"，
            "订单"： 1

          [，]
            "@class"："org.apereo.cas.生成婴儿归因释放政策"， 
            "顺序"：0
          [
      ]
    ]
  }
}
```

## 属性值筛选器

虽然每个策略都定义了给定服务可能允许哪些主要属性，但 每个策略都可以设置可选属性筛选器，以进一步清除基于其</strong>**值的属性。</p>

[本指南](Attribute-Value-Release-Policies.html) 了解更多。
